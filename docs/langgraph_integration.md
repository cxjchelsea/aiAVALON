# LangGraph 集成方案

## 概述

使用 LangGraph 可以更好地管理游戏状态流转和 LLM 调用，提供以下优势：

1. **状态机管理**：清晰定义游戏阶段转换
2. **LLM 调用优化**：统一的 LLM 调用管理、重试、缓存
3. **并发处理**：支持多个智能体并行决策
4. **可观测性**：更好的日志和调试支持

## 架构设计

### 使用 LangGraph 的游戏流程

```
游戏开始
  ↓
讨论阶段 (DiscussionNode)
  ↓
投票阶段 (VotingNode)
  ↓
任务执行阶段 (MissionNode)
  ↓
检查游戏结束条件 (CheckWinConditionNode)
  ↓
[如果未结束] 下一轮 / [如果结束] 游戏结束
```

### 关键节点

1. **DiscussionNode**: 处理讨论阶段
   - 所有玩家发言
   - 队长决定队伍

2. **VotingNode**: 处理投票阶段
   - 收集所有玩家投票
   - 处理投票结果

3. **MissionNode**: 处理任务执行
   - 收集任务投票
   - 更新游戏状态

4. **CheckWinConditionNode**: 检查游戏结束条件
   - 检查任务完成数
   - 检查流局次数
   - 决定是否进入刺杀阶段

## 实现步骤

### 1. 安装依赖

```bash
pip install langgraph langchain langchain-openai
```

### 2. 创建游戏状态图

使用 LangGraph 的 StateGraph 来定义游戏流程。

### 3. 优化 LLM 调用

- 使用 LangChain 的 LLM 封装
- 添加重试和超时机制
- 实现响应缓存（可选）

### 4. 并发处理

- 使用 LangGraph 的并发节点支持
- 多个智能体可以并行生成发言和决策

## 优势

1. **更清晰的状态管理**：游戏阶段转换更明确
2. **更好的错误处理**：统一的异常处理机制
3. **可扩展性**：易于添加新功能
4. **可测试性**：每个节点可以独立测试

## 注意事项

- LangGraph 会增加系统复杂度
- 需要学习新的框架API
- 对于当前规模的项目可能有些过度设计

## 建议

如果游戏逻辑已经稳定，可以考虑：
1. 先修复当前的游戏结束逻辑问题
2. 如果后续需要更复杂的功能（如多局游戏、统计分析等），再考虑引入 LangGraph

